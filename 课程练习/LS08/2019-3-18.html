<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
/*    //对象 instanceof 构造函数
    //1、判断对象是否可以使用构造函数实例化得到
    //2、判断在对象的原型链上能否找到函数的prototype属性
    function Person(username,age){
        this.username = username;
        this.age = age;
    }
    var person = new Person("zhangsan",20);
    console.log(person);
    console.log(person.__proto__ == Person.prototype);//true
    console.log(person.__proto__.__proto__ == Object.prototype);//true
    console.log(person.__proto__.__proto__ == Person.prototype);//flase
    console.log(person instanceof Person);//true
*/

/*    function fn1(x){
        //length的属性表示的是形参的个数
        //arguments是函数调用时，实参类型组集合
        console.log(fn1.length);//形参个数
        for(var i=0; i<arguments.length;i++){
            console.log(arguments[i]);
        }
    }
    fn1(1,2,3);
*/

/*    function fn1(){
        console.log(fn1.caller);
    }
    function fn2{
        fn1();
    }
    fn2();
*/
/*  //递归 
    var func = function(n){
        if(n<=0){
            return 1;
        }else{
            return n.argunments.caller(n-1);
        }
    }
*/

/*    var objA = {"objName":"AAA"};
    var objB = {"objName":"BBB"};
    objA.foo = function(){
        console.log(this.objName);
    }
    objA.foo();
    //方法.call();
    objA.foo.call(objA);
    objA.foo.call(objB);
*/

/*    function Person(username,age){
        //this指代使用该函数的实例化对象
        this.username = username;
        this.age = age;
    }

    function Student(username,age,sex){
        //Person 指代的this对象就是Student的实例化对象
        Person.call(this,username,age);
        this.sex = sex;
    }
    var student = new Student("zhangsan",20,"male");
    console.log(student);
*/
 /*   //swim.call(对象，参数，参数)
    function swim(m,n){
        console.log(this.name,m,n);
    }
    var bird = {
        name:"polly",
        fly:function(m,n){
            console.log(this.name,m,n);
        }
    };
    var me = {
        name:"ABC"
    };

    //bind 切换函数的this指向，但是不会立刻执行，而是形成一个新的函数，（）内也可以添加其他参数类apply，call
    var swim1 = swim.bind(bird);
    swim();
    //apply
    swim.apply(bird,["hello","world"]);//参数以数组形式传入
    swim.call(me,"hello","world");
*/
    var obj = {
        "objName":"obj1",
        "show":function(){
            function fn1(){
                console.log(this.objName);
            }
            fn1();
        }
    }
    obj.show();
</script>
</html>